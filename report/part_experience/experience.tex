%!TEX root = ../report.tex
\chapter{Project Evaluation}\label{chap:evaluation}
The overall goal of this project was to make the GIRAF apps more usable and refined than when we inherited it from last year's students. This goal has been apparent throughout the different parts of the project: From the individual backlog items the groups have worked on, to the refinements made to the development method with build automation and continuous integration. Our personal goal was to improve build automation and the overall testing facilities of the GIRAF project. In this chapter, we will evaluate the project with respect to these goals.

There are several layers to evaluate: The technical work, i.e.\ the backlog items we completed as well as other tasks we completed by necessity; the development process followed in the group; the accomplishments of the multi-project as a whole, i.e.\ all individual group's collective progress; and finally the process surrounding the entire multi-project.

\begin{chapterorganization}
  \item In \sectionref{conc:userstories} we evaluate the technical work we have done this semester in terms of what user stories we selected and completed;
  \item in \sectionref{conc:internalprocess} we evaluate the development method followed internally in our group;
  \item in \sectionref{conc:multi_project_process_eval} we evaluate the development method employed across the multi-project;
  \item in \sectionref{conc:multi_project_eval} we evaluate the collective progress towards the goal of evolving the GIRAF project into something useful, helping autistic citizens.
\end{chapterorganization}

\section{Group Work on User Stories}\label{conc:userstories}
During this project we have completed 16 backlog items. The result of this work is a significant improvement to the build environment, in particular the continuous integration platform, Jenkins, compared to what we inherited. When we started, the continuous integration platform was just a regular build platform. We changed the configuration such that the platform automatically builds a new version whenever changes are pushed to the master branch of a repository. We also run any unit and UI tests after the build process, and we only consider the build successful if all the tests pass. If the build is successful we also publish the new version. If it is an app, it is published on the alpha track on Google Play. If it is a library the commit message indicates whether to publish a major or minor release, a patch or a development snapshot. Before all these changes, developers manually had to start the builds in Jenkins and no test were run. When we started there were 13 job configurations on the continuous integration platform, and now we have 42 configurations. We have enabled email notifications so that whenever a build fails, the developer responsible for the bad build gets a notification email with a link to the failed build. We provide statistics like code coverage as well as lint errors and warnings. The automation of the build process gives quick feedback when errors occur. This has helped improved the overall stability of the apps. The build and test automation ensures that frequent integration with the master branch proceeds smoothly, as errors will be spotted immediately.

There are very few tests of the apps in general, so we run monkey tests every night, where the newest version of every app is tested. If an app crashes during a test, a stacktrace is available as well as a screenshot taken the moment the app crashed. The monkey tests were only really functioning quite late in the project and therefore have had limited impact on the overall stability of the apps.

We have worked on decreasing the build time of jobs in Jenkins. We have succeeded in relatively speeding up the build process every time, but we still end up with slower build processes than when we started. This is because a build does more work now than what was done before.

We have also worked on different tasks which make life easier for the developers. In collaboration with the Git responsible group we have removed submodules from Git, which were a hassle for the developers to work with. Instead we have libraries which are pre-compiled and the different versions are specified in the build script. The developers also wanted a easy way of installing the newest version of all apps on a tablet. We have developed scripts which accomplishes this task.

In addition to Jenkins, we have also had the responsibility for the development process in general. During handling these responsibilities, we gather information which is relevant for some or all of the other groups in the multi-project. To make this information available, we use the wiki on Redmine. We have made many guides on different topics. These are:

\begin{itemize}
  \item UI testing
  \item Unit testing
  \item Dependency management
  \item Multi-project development process
  \item Continuous integration
\end{itemize}

As a whole, the developers now work in a simple-to-use environment, which provides many services that help improve the stability of the software.

\section{Internal Development Method}\label{conc:internalprocess}
In our group we have used a physical sprint backlog containing all the tasks to complete in a sprint. These tasks are estimated. In combination with a burndown chart we have been able to track our progress throughout a sprint and prioritize tasks. When we were behind schedule, we were able to identify the least important tasks and remove them from our sprint backlog. This way, we ensured that we always worked on the most important backlog item. The Daily Scrum meeting has ensured that we consistently updated our sprint backlog and burndown chart. Even though there were times where we got behind schedule, we have been able to adapt and Scrum has worked well for us. The method fits nicely with the Scrum of Scrum method used on the multi-project level, especially the common language of backlog items like user stories has been very useful and makes an effortless transition of backlog items between the subproject and group levels.

\section{Multi-Project Development Method}\label{conc:multi_project_process_eval}
The multi-project has been organized according to Scrum of Scrums. We have continually throughout all sprints refined the method to improve our development process. What is described in \chapterref{chap:sw_dev_method} is the result of refining the Scrum method to suit our needs. The work we have put into formalizing the development method and the following refinements of it has freed the other groups to dedicate their time to completing their user stories related to more practical work on the GIRAF project. The development method we have defined has brought a close collaboration with the customer which has enabled all groups to reach the GIRAF project goals.

In sprint 1 and to some degree sprint 2, there was some confusion among the groups regarding the development method. We believe this was the reason why some of the meetings ran over time, e.g.\ the \db sprint 2 planning meeting described in \sectionref{sec:S2_db}. We therefore had to spend time clarifying this. We underestimated the need for a clear process specification, which we will do if we are to manage a similar project in the future.

At each sprint planning meeting, the requirements of the external customers have been mostly diffuse. Their desires changes over time. For this an agile and adaptive development method is suitable. Part of working agile is collaborating closely, which groups have been good at doing.

We initially kept the product backlog on Redmine. However, this tool proved to be inadequate as the product owners switched to using Google Docs to manage the backlog. The backlog became fragmented, and each product owner had their own backlogs. This made it very hard to find out which backlog items that were being worked on in a given sprint, and made it hard to track progress. The product owners also had to spend time and resources during the last sprint on unifying the product backlog and making sure it was up to date. If there had been a more rigid, perhaps tool assisted, method for organizing and maintaining the product backlog, it would have been easier to get an overview of the heading of the multi-project.

\todo{Nyt l√¶s dette}The development process has not been perfect. There have been problems during the project and we have adjusted the method continually to adapt to changing conditions and respond to concerns raised by the developers. However, the method will never be perfect as conditions are bound to change in the future, and the method will have to be adjusted accordingly.

\section{The Development of GIRAF}\label{conc:multi_project_eval}
When we started working on the GIRAF project, we overtook multiple apps out of which only few were usable. Additionally, the user interface was very inconsistent between the apps, making the GIRAF apps feel and look like independent apps rather than a single suite of apps. It was the main goal of this project to solve these problems by making existing apps stable and consistent.

Throughout the project, every \gui{} group has solely worked on user stories related to existing apps. The main focus of the initial sprints was bug fixing, and as bugs became resolved, new features started to be developed. Design guidelines were formulated and implemented in the different apps.

The \db{} groups have written several automated tests in the database libraries to ensure that new changes do not break existing functionality. They have implemented basic synchronization between tablets and generally accommodated structural changes needed by the \gui{} groups.

The \bd{} groups have configured a build and test environment which makes it easier for everyone to write automated tests and discover breaking changes in code. They have made every build reproducible, making it easier to reproduce bugs from crash reports. This has had an influence on the stability of the apps.

Overall, every group has been very committed to making the GIRAF project stable and consistent. During sprint reviews, the external customers have indicated a satisfaction with the features we develop. They are satisfied that we develop what they ask for and that the apps look consistent. Therefore, we consider that the multi-project has successfully accomplished the overall goal of the project.
