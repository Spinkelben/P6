\chapter{Evaluation of the Multi-Project}\label{chap:evaluation}
\todo{Chapter introduction}

There are several layers to evaluate: The technical work, i.e.\ the user stories we completed as well as other tasks we completed by necessity; the development process followed in the group; the accomplishments of the multi-project as a whole, i.e.\ all individual group's collective progress; and finally the process surrounding the entire multi-project. \todo{Maybe a figure to illustrate the structure of this, going from the inner-most layer to outer-most?}

\begin{chapterorganization}
  \item in \sectionref{conc:userstories} we evaluate the technical work we have done this semester in terms of what user stories we selected and completed;
  \item in \sectionref{conc:internalprocess} we evaluate the development method followed internally in our group;
  \item in \sectionref{conc:multi_project_eval} we evaluate the collective progress towards the goal of evolving the GIRAF project into something useful, helping autistic citizens;
  \item in \sectionref{conc:multi_project_process_eval} we evaluate the development method employed across the multi-project.
\end{chapterorganization}

\section{Group Work on User Stories}\label{conc:userstories}

During this project we have accomplished a number of backlog items. The result of all this work is that the build environment, the continuous integrations server in particular, is significantly improved from what we inherited. When we started the continuous integration server was just a regular build server. We changed the configuration such that the server automatically builds the new version whenever changes are pushed to the master branch. We also run any unit and UI tests after the build process, and we only consider the build successful if all the tests pass. If the build was successful we also publish the new version. If it is an app, it is published on the alpha track on the Google Play Store, if it is an library the commit message decides whether to publish a major or minor release, a path or a development snapshot. Before all these changes, developers manually had to start the builds on the server and no test were run. We have enabled email notifications so whenever a build fails, the developer responsible for the bad build gets a notification email with a link to the failed build. Furthermore we provide statistics on successful builds. We provide statistics like code coverage, and lint errors and warnings. The automation of the build process gives us quick feedback when errors occur and has helped greatly with heightening the overall stability of the apps, and provides the confidence that it requires to push changes to the master branch often. 

There are very few tests of the apps in general, so we run monkey tests every night, where the newest version of every app is tested. If an app crashes during a test, a stacktrace is available as well as a screen capture of the app, captured as the app crashed. The monkey tests were only really functioning quite late in the project and therefore have had limited impact on the overall stability of the apps.

We have worked on several backlog items which requested that the builds were faster. We have succeeded in speeding up the build every time, but we still end up with slower builds than when we started. This is because we do much more work now when we build, than what was done before.

We also have worked an different tasks which would make life easier for the developers. In collaboration with the Git group we have removed submodules from Git, which were a hassle for the developers to work with, instead we have libraries which are pre-compiled and the different versions are specified in the build script. The developers also wanted a easy way of installing the newest version of all apps on a tablet. We have developed a script which accomplishes this task.

In addition to Jenkins, we also have responsibility for the development process in general. While we handle these responsibilities we gather information which are relevant for some or all of the other groups in the multi-project. To make this information available we use the wiki on Redmine. We have made many guides on different topics including UI testing, unit testing, multi-project development process, and continuous integration.

As a whole, the developers work in a simpler to use environment, which provides more services that improve confidence in the stability of the software.

\section{Internal Development Method and Process}\label{conc:internalprocess}
\todo{Var vores scrum god? Estimering: Burndown har hjulpet os med at prioritere de vigtigste opgaver. SCRUM passer godt som proces til undergrupper. Daily scrum er godt}

\section{Multi-Project as a Whole}\label{conc:multi_project_eval}
\todo{Place this somewhere: Homogenous project og vi har ikke tilført mange nye features. Kunde til sprint review: Apps ser ens ud og det vi har bedt om}

\section{Multi-Project Process}\label{conc:multi_project_process_eval}
\todo{Opsummere hvordan procesen har kørt, hvad der var godt og hvad der var skidt. Læg vægt på at processen løbende er blevet evalueret.}
\todo{Tilvænning, var der noget der overraskede os ved at arbejde så mange sammen?}
\todo{Har vi forbedret processen løbende?}
\todo{status meetings}
\todo{Håndtering af backlog items.}

\chapter{Recommendations for Future Developers}\label{chap:future_dev_recommendations}
\todo{kapitel til alt hvad vi syntes de næste skal vide hvis de ikke har læst resten af rapporten}

\todo{De bør få et ordentligt testmiljø op!}

\section{Process Recommendations}
\todo{Hvordan de bør styre procesen næste år. Anbefalet en samlet, unified backlog!}

\section{Recommandations for Jenkins}
\todo{Hvad der kan gøres for at forbedre jenkins fremover. Referer til den nuværende jenkin struktur appendix}
For future students: How to make new libraries published (server file /srv/jenkins/project\_version\_codes/libversion)
