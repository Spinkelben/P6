% Chapters
\input{part_sprint2/sprint_planning}
\input{part_sprint2/improving_automated_testing}
\input{part_sprint2/google_play_upload}

\chapter{Restructuring of Jenkins}
The setup of Jenkins used in sprint 1 was tedious to work with since all jobs were configured independently. If a change had to be made to several jobs, we would have to manually configure the change in each job. Not only did this take a considerable amount of time, but it was also prone to human errors during the process. We install a Jenkins plugin which allows jobs to have inheritable properties. As such, when we decide to make a change to e.g.\ the build system, it will not be necessary to change this in each job. Instead, the change can be made one place, and since all relevant jobs inherit they will inherit this change. This also ensures that jobs follow a consistent pipeline and thus do not differ in from job to job.

We find that almost all jobs on Jenkins will benefit from this, and we see two general categories that are sufficiently distinct: Android apps and Android libraries. We create an abstract job for each of these. They do overlap somewhat in functionality, which means we have to create an abstract job for each job task. As such we create abstract jobs for e.g.\ \emph{run Gradle}, \emph{run unit tests}, \emph{find and move APKs}, and \emph{publish lint report}. The abstract jobs \emph{Android app} and \emph{Android library} inherit from the small abstract tasks that are relevant.

Doing this also means we have to recreate all jobs, and a result of this is that the build history of each job is lost. We do not consider this a major problem, since most of the projects at this point do not build anyway.

We have modelled this as an OOP class diagram in \todo{Pæn graf over Jenkins jobs og inheritance?}

\todo{Nævn at vi ikke har en specifik user story for this. Det er refaktorering}


\input{part_sprint2/faster_build}
\input{part_sprint2/sprint_review}
