\chapter{Software Configuration Management Plan}\label{chap:sw_intro_cm}
Software configuration management is an important part of any large software project. Configuration management can be defined as \emph{the discipline of identifying the configuration of a system at distinct points in time for the purpose of systematically controlling changes to the configuration and maintaining the integrity and traceability of the configuration throughout the system life cycle} \parencite[ch.6, p.6-1]{swebok}. The large size of the multi-project requires some form of software configuration management to handle and track the changes in the software. It can ease the workflow of developers and assure the quality of the product \parencite[ch.6]{swebok}. 

%\section{Software Configuration Management Plan}\label{sec:SCM_vision}
Our role as a group is to manage the development method, and therefore we have the responsibility of creating a Software Configuration Management Plan (SCMP). An SCMP specifies how items are controlled, by who, and by what tools \parencite[ch.6]{swebok}. The Guide to the Software Engineering Body of Knowledge (SWEBOK) \parencite[ch.6]{swebok} identifies some key areas of software configuration management.

This chapter describes how we plan and execute configuration management. We aim to make it as easy as possible for the developers, and therefore we will automate as much as possible.

\begin{chapterorganization}
  %\item in \sectionref{sec:SCM_vision} we identify a plan for the software configuration management and identify specific areas we want to improve or implement in the software configuration management practice;
  \item in \sectionref{sec:SCM_orgcontext} we \todo{\dummy};
  \item in \sectionref{sec:SCM_configitems} we \todo{\dummy};
  \item in \sectionref{sec:SCM_tools} we \todo{\dummy}.
\end{chapterorganization}

\section{Organizational Context}\label{sec:SCM_orgcontext}
In order to plan the software configuration management it is important to understand the organizational structure \parencite[ch.6]{swebok}. The multi-project has a quite unique structure. The development is performed and managed by students who work in small groups that each acts as a independent entity. While the product is being developed for the clients, the groups have other priorities than customer satisfaction. The work is being done for free, the motivation of the groups is to work on something interesting such that they can write a good report detailing the work and get a good grade. While we can suggest a process with specific procedures, we have no authority over the other groups. This means that the groups preferences weigh heavily when we select which software configuration management procedures to follow. In general, the feeling \todo{consensus?} in the groups are that the less formal communication and bureaucracy the better. This is reflected in the choice of Scrum as the basis for the project management, and will influence all of the decision regarding the software configuration management process planning and execution.

\section{Configuration Items}\label{sec:SCM_configitems}
A configuration item is a piece of software or a combination of hardware and software which is managed as a single entity \parencite[ch.6]{swebok}. Due to the desire of the groups to minimize overhead, there is no formal process which explicitly identifies the items that are to be controlled. The configuration items are identified by the groups of previous years, and by the groups during the project start up. New items might be discovered in the future, and they will be discussed at the multi-project status meetings and be described in the relevant sections in this report \todo{Tjek at vi g√∏r dette}. The currently identified items and how they are managed are:

\begin{description}
  \item[Requirements] The requirements are managed by the subproject product owners as described in \sectionref{sec:project_overview}.
  \item[Built Application] The currently deployed version of all applications is controlled by the group responsible for Google Play. The current version of internally built applications are controlled by us through automatic building. When a change has been made to an application, it is re-built and all tests are run. We ensure that the tests are run automatically, but it is the responsibility of the developers of each application to write the tests. The iOS applications developed on previous years are not under configuration management, as it was decided at the semester start that those applications will not be worked on.
  \item[Built Libraries] The binaries of all libraries are stored on a Maven repository. When a library builds successfully the binary is uploaded to the repository as a snapshot version. When the developers of the libraries decide that a new release should be made available, new versions of the libraries are uploaded. This way several versions of library binaries are stored.
  \item[Application and Library Source Code] The source code for the applications and libraries are controlled with Git \parencite{gitwebsite}. Each application and library has it own repository. The external dependencies are managed with Gradle which gets the correct version of each external library from Maven repositories. This ensures that we can control when to update the dependencies. Again, the source code for the iOS applications will not be managed.
  \item[Source Code Documentation] Documentation of source code is written by the developers of the software in Javadoc style. There is no formal process ensuring that it is actually written, and so it is solely up to the developers to do so. Documentation is, however, to be automatically generated.
  \item[The Supported Versions of the Android OS] Previous years selected the supported version of the Android OS to be API 15 and up. When new versions of the Android OS are released, they will be managed as well, and applications should be able to run on those versions.
  \item[The Supporting Tools Gradle and Android Studio] The developers on the multi-project use Android Studio as the main development tool for the Android applications. The version of Android Studio and Gradle are maintained by the \bd groups and any decision to upgrade is theirs. When the semester started the Android Studio and Gradle was upgraded. The Git group mainly handled this activity. We merged the upgrade from a different branch on Git to the master branch. The used version of Android Studio is 1.0.2 and 2.2.1 for Gradle.
\end{description}
We do not want to set up a change control board\parencite[p. 6-9]{swebok} (who can approve or reject change requests) since we use an agile development method. Setting up such a board would create unnecessary overhead and delay groups in doing their work.

\section{Tools}\label{sec:SCM_tools}
We use the following tools to manage the configuration items identified:

\begin{description}
  \item[Git] Git is used as the version control as mentioned previously. This was set up by previous years, and we continue to use their setup. \group{8} manages Git.
  \item[Jenkins] Jenkins is used to automatically build and test applications. Jenkins is detailed in \sectionref{sec:jenkins}. Jenkins is used for all applications throughout the multi-project, except for the iOS applications. We manage Jenkins.
  \item[Artifactory] The Artifactory tool is a Maven repository that stores various versions of binaries of the libraries in the multi-project. \todo{Ref til hvor Artifactory bliver beskrevet i detajler}
  \item[Doxygen] We use Doxygen to generate source code documentation. The use of Doxygen is described further in \sectionref{sec:automated_documentation_gen}. Doxygen is managed by us, but the documentation itself is managed by the developers and \group{5} who issue guidelines on the documentation.
\end{description}