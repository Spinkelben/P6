\chapter{Software Configuration Management}\label{chap:config_management}
Software configuration management is an important part of any large software project. Configuration management can be defined as \emph{the discipline of identifying the configuration of a system at distinct points in time for the purpose of systematically controlling changes to the configuration and maintaining the integrity and traceability of the configuration throughout the system life cycle} \parencite[ch.6, p.6-1]{swebok}. The large size of the multi-project requires some form of software configuration management to handle and track the changes in the software. It can ease the workflow of developers and assure the quality of the product \parencite[ch.6]{swebok}. This chapter describes how we plan and execute configuration management. We aim to make it as easy as possible for the developers, and therefore we will automate as much as possible.

\begin{chapterorganization}
  \item in \sectionref{sec:SCM_vision} we identify a plan for the software configuration management and identify specific areas we want to improve or implement in the software configuration management practice;
  \item in \sectionref{sec:jenkins} we describe the continuous integration tool, Jenkins, that we use in the project;
  \item in \sectionref{sec:build_automation} we explain how we set up automation of the builds and discuss version control branching strategies as well as automated testing and lint checking;
  \item in \sectionref{sec:automated_documentation_gen} we explain how we set up automated documentation generation.
\end{chapterorganization}

\begin{abbreviations}
  \item[test] TEST
  \item[test2] More test
\end{abbreviations}

\section{Software Configuration Management Plan}\label{sec:SCM_vision}
Our role as a group is to manage the development method, and therefore we have the responsibility of creating a Software Configuration Management Plan (SCMP). A SCMP specifies how items are controlled, by who, and by what tools \parencite[ch.6]{swebok}. The Guide to the Software Engineering Body of Knowledge \parencite[ch.6]{swebok} identifies some key areas of software configuration management. In this section we will discus the Software Configuration Management planning.

\subsection{Organizational Context}
To plan the software configuration management it is very important to understand the organizational structure \parencite[ch.6]{swebok}. The multi-project has a quite unique structure. The development is performed, and managed by, students who work in small groups. Each group acts as a independent entity. While the product is being developed for the clients, the groups have other priorities than customer satisfaction. The work is being done for free, the motivation of the groups is to work on something interesting such that they can write a good report detailing the work and get a good grade. While we can suggest a process with specific procedures, we have no authority over the other groups. This means that the groups preferences weigh heavily when we select which software configuration management procedures to follow. In general the feeling in the groups are that the less formal communication and bureaucracy the better. This is reflected in the choice of Scrum as the basis for the project management, and will influence all of the decision regarding the software configuration management process planning and execution.

\subsection{Configuration Items}
A configuration item is a piece of software or a combination of hardware and software which is managed as a single entity \parencite[ch.6]{swebok}. Due to the desire of the groups to minimize overhead, there is no formal process which explicitly identifies the items that are to be controlled. The configuration items are identified by the groups of previous years, and by the groups during the project startup. New items might be discovered in the future, and they will be discussed at the status meetings. The currently identified items and how they are managed are:

\begin{description}
  \item[Requirements] The requirements are managed by the subproject product owners as described in \sectionref{sec:project_overview}.
  \item[Built application] The currently deployed version of all applications is controlled by \group{5}. The current version of internally built applications are controlled by us through automatic building. When building applications are tested to ensure they comply with the requirements that they are tested against. We ensure that the tests are run automatically, but it is up to the developers of each application to test them. How automatic testing and building is done is described in \sectionref{sec:build_automation}. The iOS applications developed on previous years are not under configuration management, as it was decided at the semester start that those applications will not be worked on.
  \item[Application source code] The source code for the applications are controlled with Git \parencite{gitwebsite}. Each application has it own repository. The external dependencies are managed with Gradle which gets the correct version of each external library from Maven repositories. That way the new version of the dependencies can be released when needed. Again the source code for the iOS applications will not be managed.
  \item[Source code documentation] Documentation of source code is done using Javadoc that the developers of the software write. There is no formal process ensuring that these are actually written, and so it is solely up to the developers to do so. Documentation is, however, to be automatically generated. We describe this documentation generation in \sectionref{sec:automated_documentation_gen}.
  \item[The supported versions of the Android OS] Previous years selected the supported version of the Android OS to be API 15 and up. When new version of the Android OS are released, they will be managed as well, and applications should be able to run on those version.
  \item[The supporting tools Gradle and Android Studio] The developers on the multi-project use Android Studio as the main development tool for the Android applications. The version of Android Studio and Gradle are maintained by the \bd groups and any decision to upgrade is theirs. The used version of Android Studio is 1.0.2 and 2.2.1 for Gradle.
\end{description}

We do not want to set up a change control board (who can approve or reject change requests) since we use an agile development method. Setting up such a board would create unnecessary overhead and delay groups in doing their work.

\subsection{Tools}
We use the following tools to manage the configuration items identified:

\begin{description}
  \item[Git] Git is used to control the version control as mentioned previously. This was set up by previous years, and we continue to use their setup. \group{8} manages Git.
  \item[Jenkins] Jenkins is used to automatically build and test applications. Jenkins is detailed in \sectionref{sec:jenkins}. Jenkins is used for all application throughout the multi-project, except the iOS applications. We manage Jenkins.
  \item[Doxygen] We use Doxygen to generate source code documentation. The use of Doxygen is described further in \sectionref{sec:automated_documentation_gen}. Doxygen is managed by us, but the documentation itself is managed by the developers and \group{5} who issue guidelines on the documentation.
\end{description}

\section{Jenkins}\label{sec:jenkins}
\todo{Rename evt. til continuous integration og forklar hvorfor vi vil have noget af det. Så kan vi skrive, at Jenkins er et værktøj til at udføre det. På den måde argumenterer vi hvorfor vi bruger Jenkins.}
Jenkins had been installed and setup by previous years. Jenkins is an open source tool for continuous integration \parencite{JenkinsWebsite}. It supports source control management tools such as Git \parencite{gitwebsite}, as well as build automation tools such as Maven \parencite{mavenwebsite}. It is extensible via numerous available plugins. Jenkins allows for a sophisticated continuous integration setup, however the setup by previous years is rather basic and we want to improve it in several ways.

\todo{Overvej at definere hvad Continuous Integration er (ifølge Fowler)}

\subsection{Upgrading Jenkins and Plugins}
We inherited the old installation which had not been updated in a long time. Jenkins itself and all the Jenkins plugins had updates available. We updated everything to the newest versions.

There are a number of unused plugins enabled in Jenkins. We tried to disable these, but this resulted in failure to start Jenkins. We undid the changes and have decided not to remove these unused plugins as it will not hinder further configuration of Jenkins.

\subsection{Setting up Roles in Jenkins}
The inherited Jenkins installation was open to anybody. We do not find this sensible as we need to control the build process. Allowing everybody access will likely end in someone modifying a setting without our knowledge. Because we set up a mechanism for automatic build, other people do not need the option to start builds manually. It might even interfere with the automatic build, if other people have access to the Jenkins configuration.

It is important that everyone can see the build process, however. According to Martin Fowler, it is important that everyone is able to see the state of builds and which parts of the overall system that are currently worked on \parencite{fowlerCI}. In addition to this, we find it important that developers can follow the testing process of their new code, and how stable different projects are. This way, we are able to transfer human resources between projects if needed, and it may work as a motivation for the developers to create stable builds. Because of this, we give developers read-only access to Jenkins, while we are the only people with write access.

\section{Build and Test Automation}\label{sec:build_automation}
The inherited project has no build automation, we decide to set it up in two stages. In the first stage we schedule all jobs to run nightly. This gives us some level of build automation and gives us time to investigate merge strategies and set it up properly. The nightly job is set to run every day at midnight.

\subsection{Merge Strategy}\label{sec:branching_strategy}
As the name \emph{continuous integration} suggests, code should be integrated into the mainline (or \emph{master branch}) of the project frequently \parencite{fowlerCI}. According to Martin Fowler, frequent merges ensure that merges generally will be small and easy to perform \parencite{fowlerFeatureBranch}. The master branch must be stable and always in a release-ready state. If it breaks, it should be the team's first priority to fix it. A consequence of this is that the whole team is affected when a developer introduces an error, which has a negative influence on the overall productivity.

    We assess two strategies to accommodate these consequences of continuous integration: the \emph{direct commit strategy}\todo{selfopfundet navn. Må vi gerne kalde det det? SVAR: Der findes ikke et standard navn for det.} and the \emph{pre-tested commit strategy}. In the direct commit strategy, every developer integrates its code directly to the master branch. It is the developer's own responsibility that the code works. This is the simplest, and one may say, the most agile way of integrating code with the master branch. An illustration of the direct commit strategy can be seen in \figureref{fig:commit_stratagy_a}. A developer creates a branch from the master branch and develops their code (commits \mono{B} and \mono{C}) on this before merging it directly into the master branch (commit \mono{D}).

An alternative to integrating code directly with the master branch is to use pre-tested commits \parencite{fowlerPendingHead}. A pre-tested commit uses a special branch which is an intermediate place for building and testing code before it is merged into the master branch. The code will only be merged into the master branch if it passes the tests. This ensures that the master branch will always work, but the merging workflow will be more complex as the developer must pull from one branch and push to another. The strategy is illustrated in \figureref{fig:commit_stratagy_b}. The developer creates a branch from the master branch and develops its code on here. When completed, the code is merged with the intermediate branch (commit \emph{\mono{I}}), which will build and test the code before eventually merging it with the master branch (commit \mono{D}).

For the first sprint, we choose to implement the direct commit strategy, primarily because of its simplicity. It is important to get continuous integration up running so the developers can start to develop code, and it would be too costly to spend time implementing a pre-tested commit strategy as this will block the progress of all other developers. We are unsure about how the developers handle the increased responsibility, so in the preparation of the second sprint, we will evaluate this strategy and consider whether we should implement the pre-tested commit strategy instead.

\begin{figure}
\begin{subfigure}[b]{\linewidth}
\centering
\begin{tikzpicture}
% MASTER
\node[text width=2cm] at (0,1) {\mono{master}};
\node(master_a) [draw, circle, minimum size=0.5cm] at (2,1) {\mono{A}};
\node(master_head) [draw, circle, minimum size=0.5cm] at (5,1) {\mono{D}};
\node(master_head_label) [] at (5,2) {\mono{HEAD}};
\draw[->, >=latex] (master_head) -- (master_a);
\draw[->, >=latex] (master_head_label) -- (master_head);

% LOCAL
\node[text width=2cm] at (0,0) {\mono{dev\_branch}};
\node(local_b) [draw, circle, minimum size=0.5cm] at (3,0) {\mono{B}};
\node(local_c) [draw, circle, minimum size=0.5cm] at (4,0) {\mono{C}};
\draw[->,>=latex] (local_b) -- (master_a);
\draw[->,>=latex] (master_head) -- (local_c);
\draw[->,>=latex] (local_c) -- (local_b);
\begin{pgfonlayer}{background}
  \filldraw [line width=4mm,join=round,black!10]
      (-1, 1.2)  rectangle (6,0.8)
      (-1, 0.2)  rectangle (6,-0.2);
\end{pgfonlayer}
\end{tikzpicture}
\caption{The direct commit strategy}\label{fig:commit_stratagy_a}
\end{subfigure}\\
\begin{subfigure}[b]{\linewidth}
\centering
\begin{tikzpicture}
% MASTER
\node[text width=2cm] at (0,2) {\mono{master}};
\node(master_a) [draw, circle, minimum size=0.7cm] at (2,2) {\mono{A}};
\node(master_head) [draw, circle, minimum size=0.7cm] at (6,2) {\mono{D}};
\node(master_head_label) [] at (6,3) {\mono{HEAD}};
\draw[->, >=latex] (master_head) -- (master_a);
\draw[->, >=latex] (master_head_label) -- (master_head);

% PENDING HEAD
\node[text width=2cm] at (0,1) {\mono{intermediate}};
\node(ph_head) [draw, circle, minimum size=0.7cm] at (5,1) {\emph{\mono{I}}};
\draw[->, >=latex] (master_head) -- (ph_head);

% LOCAL
\node[text width=2cm] at (0,0) {\mono{dev\_branch}};
\node(local_b) [draw, circle, minimum size=0.7cm] at (3,0) {\mono{B}};
\node(local_c) [draw, circle, minimum size=0.7cm] at (4,0) {\mono{C}};
\draw[->,>=latex] (local_b) -- (master_a);
\draw[->,>=latex] (ph_head) -- (local_c);
\draw[->,>=latex] (local_c) -- (local_b);

\begin{pgfonlayer}{background}
  \filldraw [line width=4mm,join=round,black!10]
      (-1, 2.2)  rectangle (7,1.8)
      (-1, 0.2)  rectangle (7,-0.2);
  \filldraw [line width=4mm,join=round,black!10]
      (-1, 1.2)  rectangle (7,0.8);
\end{pgfonlayer}
\end{tikzpicture}
\caption{The pre-tested commit strategy}\label{fig:commit_stratagy_b}
\end{subfigure}
\caption{Different branching strategies. A circles represents a commit and an arrow represents a reference to a commit.}\label{fig:commit_stratagy}
\end{figure}

\todo{Write about how we implemented this. Collab with git group?}

\subsection{Continuous Build}
The output of a build is an APK file, which is a package format used to distribute and install software onto Android. These files need to be signed before they can be installed. As such, we add a post-build task to Jenkins which signs and verifies the APK files as well as moves it into a common APK folder for all projects.

After deciding upon the merge strategies, we improve the nightly build and test automation. Instead of building and testing nightly, we automatically build and test projects whenever new code is pushed to the master branch. This gives the developer fast feedback on the integration of the code, and we are likely to discover an error in the code faster than before. The automatic build is triggered by a git-hook on each repository which is a way to execute a script when specific git events occur. The script is executed whenever something is pushed to the repository. It sends an HTTP request to the Jenkins server which triggers builds of all projects that depend on the repository.
\subsection{Continuous Deployment}
\label{sec:auto_deploy}
When we have built a project we would also like to deploy it. This was not a part of the sprint initially, but UI testing is dependent on the output of the deployment. On Jenkins there is a project called \emph{deployment} which builds all other projects, signs (only some of) them and moves them to the aforementioned directory. We remove this project and make it a part of the build process of every project to do this themselves, and ensure there are no redundant APKs present in the APK directory. By making it a part of every project we also ensure that there always is an up-to-date version of all applications whenever they pass a build, complementing our vision for continuous integration. This additional work was unplanned, and we do not have time to set it up on all projects in this sprint.

\subsection{Continuous Test}
\label{sec:test_automation}
Now that the automatic test setup is created, we examine the different types of automatic tests we can use on Android.

Because one of the ideas behind automated build is to give the developer fast feedback on the state of the code, the build and test process should be fast. The Extreme Programming (XP) development method states 10 minutes as a guideline for how long time a build should take \parencite{beck2004}. While we think this is a reasonable time, not all parts of the system can be thoroughly tested in that time. In such cases, Martin Fowler suggests that the fastest and general tests should be whenever a commit is pushed to the master branch, and slower tests can be triggered for later execution \parencite{fowlerCI}. We call these kinds of tests \emph{delayed tests}.
\subsubsection{Unit Testing}
During the initial investigation of the inherited code base we found some existing unit tests in the \gproject{Oasis-lib} project. These tests utilize the Android unit testing framework included in the Android framework \parencite{AndroidUnit}. The unit tests runs in an emulated Android environment, or on actual Android devices if any are connected to the computer. We therefore decide to postpone any further investigation into unit testing frameworks. Instead, we focus on getting the existing unit tests to run, both locally and in Jenkins. The tests were immediately runnable through Android Studio 0.4.6. However, Android Studio does something behind the scenes when it runs the tests, and therefore we could not run them from the command line, which means that we cannot run them in Jenkins. However, the most recent Android studio, version 1.0.2, uses Gradle exclusively to run the tests. This means that when the projects are migrated to the new version, we are able to run the tests with Jenkins.
The other projects did not have any tests, so we create test projects, with examples of tests to verify that Jenkins can run the tests, and to show the other groups how to create new tests.
Currently, Jenkins starts a new emulator before each project is built. This adds a significant delay to the build. The build time for the entire app has increased from 20 to 90 minutes. This is unfortunate, but for now we won't spend more time improving on this. We may return to this in a later sprint. Unit tests are the simplest tests we have, and we do not want these to be handled as delayed tests.

\subsubsection{UI Testing and Monkey Testing}
Because Android applications contain a graphical user interface, it is not sufficient to only test the backend libraries. On the overall level, there are two ways of performing automatic testing of the user interface in Android: UI tests and monkey tests. UI tests is a way of declaring specific sequences of events and their expected behaviours. For example, a test may specify a click on a settings button and assert that this actually opens the settings activity. Writing UI tests can be labor intensive, though, and the maintenance of the tests can get quite comprehensive. As an alternative, monkey testing can be used. Monkey testing is a test performed by inputting a random sequence of events, such as buttons clicks and touches, into a device. That way, the user interface of an app is randomly tested. There are no guarantees that all parts of the app will be tested, but the setup of the test is very simple. The official Android SDK has monkey testing facilities built in, and there exists a Jenkins plugin for running these. Because of the simplicity of monkey testing, and because the GUI application developers have requested this as a tool for discovering bugs in the code, this is the way we automatically test the user interface. We plan to run monkey tests on Jenkins during the night, as delayed tests, when the server otherwise is idle. The developers will get notified if issues are found.

While the Android monkey tool can test multiple applications at once, the Jenkins plugin does not support that feature. The plugin is open source, so we add support for this feature which will be part of its next release.

Additionally the plugin requires the installation of the apps to test. The continuous deployment task, was not finished, so there are no APKs available for the monkey tester. Therefore the automatic UI testing could not be completely set up and ready in this sprint.

\subsubsection{Concolic Testing}
Concolic testing is a way to statically analyze code in order to find bugs, e.g.\ potential null pointer exceptions. Concolic testing uses a combination of symbolic execution and testing of particular paths in order to maximize code coverage \parencite{concolic_testing_2015}.

To our knowledge, the only framework for concolic testing that works with Android Projects is Acteve \parencite{AnandNHY12, AnandH11}. The documentation for this framework is non-existent, and we cannot find anything except for an unsuccessful attempt to build and run Acteve \parencite{chenxiong-acteve}.

We already have unit testing and many crash reports to occupy the time of many multi-project groups, and as such we do not think concolic testing is worth the payoff, so we will not spend more time investigating this.

\subsection{Automated Lint Check}\label{sec:automated_lint}
Lint checking is static code analysis that scans the source code for potential bugs and improvements. We investigate the possibility of automating lint checks on the source code, as we suspect this will uncover a wide range of improvements.

An official tool, Android Lint \parencite{AndroidLint}, for linting Android project source files exists. It checks for potential bugs and optimization improvements for correctness, security, performance, usability, accessibility, and internationalization.
\todo{This section could be shortned.}

There are some important considerations to consider before linting the source code automatically. The code base is inherited from earlier years and no lint checking to our knowledge was performed on this. Linting the code will produce a considerable amount of warnings. It is therefore not possible for us to let a build fail if it contain any warnings.

In this first sprint, we set up automating the lint check in Jenkins to be performed on all builds. The warnings are presented in the build overview screen, and we hope that having a low number of lint warnings will be incentive enough for each group to fix warnings. We consider creating an even stronger incentive if the number turns out to be too small an incentive. An example of such an incentive is having weekly or per sprint ``competitions'' where the group lowering the number of serious lint warnings the most will receive a small prize and forever be on a hall of fame.

Over time, we hope that the presence of serious lint warnings can be a reason to fail a build. We may adopt this practice in a later sprint, and to help speed up this adoption we may set it up as follows. As there are a large number of lint warnings already in the code, we will select a baseline day. Groups will not be \emph{punished} (i.e.\ the break fails) for lint warnings that were present before the baseline day. Only newly introduced lint warnings will be considered and punished. Fixing old lint warnings from before the baseline day will of course count positively.

\section{Automated Documentation Generation}\label{sec:automated_documentation_gen}
When working with a large code base, people will most likely not have insight in all parts of the code. Some kind of documentation is helpful in order to know how to use libraries. However, the developers of the multi-project do not want more documentation than absolutely necessary, nor do they want to use much time writing it. A consequence of being agile is that the system architecture is likely to change rapidly --- so it is important that little effort is required for updating the documentation. Another requirement is that the developers want the documentation for all projects in one place. Based on these requirements, we choose to use a documentation generator which automatically generates documentation from the code rather than writing such documentation manually.

We investigate the Javadoc \parencite{javadoc} and Doxygen \parencite{doxygen} tools. Both tools are cross-platform and can be integrated with Jenkins. Javadoc can generate documentation in HTML and Doxygen can generate both HTML and \LaTeX. We will generate HTML documentation which will be hosted on our server.

Javadoc is the official documentation generator for Java and generates documentation based on specially formatted comments embedded in the source code. This format is integrated in Android Studio, making the documentation easily accessible where needed. In addition, parts of the existing code already contain Javadoc comments. A problem with Javadoc, however, is that it follows the packages and classes referred in a Java file. A requirement for this is that the source code must be a correctly structured Java project in order for the tool to find the different classes. This makes it complicated to comply with the requirement of having documentation of all projects in one place, because a combination of all projects may not form a valid Java project. The source code of all projects cannot simply be copied into one directory and fed to the Javadoc tool.

The Doxygen tool is a cross-language documentation generator that supports the same documentation syntax as Javadoc. Doxygen does not follow the class dependencies but simply parses the specified files. The HTML-documentation is very similar to that of Javadoc, and because it is more convenient to use, we have chosen to use this tool for documentation generation.

\subsection{Documentation Generation in Jenkins}
We have configured a Jenkins job to generate the documentation for all projects. This job pulls the most recent state of the master branch of each project and executes the Doxygen tool on all code. On the current code base, the doxygen tool uses 3--7 minutes to generate the documentation because of the size of it. Because we do not want to block more important jobs, such as building and testing new commits, we choose to run this job nightly.

\todo{Somthing about collaboration with regards to going live with android studio migration}