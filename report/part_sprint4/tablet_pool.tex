\chapter{Further Improving Build Times}
This chapter describes our work on the user story \us{Decrease Job Build Times on Jenkins}. The developers want more rapid response to builds failing or succeeding. As explained in \sectionref{sec:faster_build_evaluation}, the emulator start-up time is a significant part of the build time, taking approximately two minutes. The emulator is used for running the tests, and as such we have to find an alternative method of running the tests.

\begin{chapterorganization}
  \item test
\end{chapterorganization}

\section{Selecting a Non-Emulator Test Method}
As explained in \sectionref{sec:non-emulator_testing} there are two ways of running tests without an emulator: testing on a physical device, and testing on the Java Virtual Machine. Testing on a physical device is the only way to realistically run tests. All groups have a tablet laying unused much of the day as well as all night, and we will utilize these unused tablets. However, it will be too tedious connecting these tablets physically to the server (the server is behind locks in the basement of Aalborg University) and we most likely will not get permission to physically connect USB devices to it.

\section{The Overall Idea}
We want to create a pool of available tablets, such that they in an easy way can be part of testing. Our plan is to setup a wireless router in vicinity of our group rooms. The wireless router broadcasts a Wi-Fi signal, and any tablet connected to this Wi-Fi will automatically be in a pool of connected tablets, available for testing. The server is able to communicate with the wireless router through the network at Aalborg University. We have acquired a wireless router from the semester coordinator, Ulrik Nyman \todo{sp}, a \emph{TP-Link TL-WDR3600}.

\section{Creating a Pool of Test Tablets}
In order to transform a garden variety wireless router into a device that maintains a pool of tablets, we flash it custom firmware. We have chosen to flash with \emph{OpenWRT}, an open source router firmware \todo{Insert citation}. OpenWRT is chosen because of earlier experience in this group with this firmware, as well as being compatible with our device and having all features we need. After flashing, we setup the basic system settings and configure the Wi-Fi network as one normally will in any home router.\todo{Perhaps mention how we tried dd-wrt but it didn't need our demands?}

We furthermore setup port forwarding to the tablets. Any device connecting to the Wi-Fi will \todo{automatically get a static IP and a port forward.}

Script is called in a cron job. Because stability and if it crashes it will be executes again. Minimum resolution is 1 minute though, which is adequate. \todo{temp.}

\section{Creating Route from Server to Tablet}
Testing the above setup revealed that the server and our router is separated on the network. The only traffic we can get through is ping. We went to IT Services at Aalborg University and got our router moved to the same network as the server. \todo{Skriv dette pænere og mere fyldestgørende?}

\section{Wireless ADB App}
The Android Debug Bridge\footnote{Android SDK tool which manages communication between a computer and a device.} (ADB) tool supports device communication over Wi-Fi out-of-the-box\parencite{AndroidADB}. This is very convenient for us, because the interface for communication between computer and device is the same no matter if the devices are connected by wire or not. To connect a device wirelessly to a computer, the following steps are to be performed:
\begin{enumerate}
  \item Connect the device to the computer using USB
  \item Run \code{adb tcpip <port>} to enable Wi-Fi debugging
  \item Disconnect the devices
  \item Run \code{adb connect <ip>:<port>} to connect to the device with the specified ip and port
\end{enumerate}
There is one problem with this, though: We do not have physical access to the server and can not attach a device using USB\@. Therefore, we need a way to avoid this step. We can do that by setting at specific property in an Android configuration file \parencite{stackoverflow-adb-tcp}. Wireless ADB is enabled by executing the following commands in the Android shell:
\begin{lstlisting}
su
setprop service.adb.tcp.port <port>
stop adbd
start adbd
\end{lstlisting}
To disable it again, the port property is simply set to \code{-1} instead of the port. However, doing this requires root permission on the device. We therefore require devices to be rooted in order to be part of the tablet pool.

To make it easy for developers to enable and disable wireless ADB (and by that add a device to the tablet pool), we develop an Android app to do this. By making it easy to join the tablet pool, we expect that developers are likely to use this feature when they do not use the device.

\section{Adapting Jenkins to Use Physical Devices}

Currently we use a Jenkins plugin called Android Emulator Plugin \parencite{jenkins-emulator-plugin} to run an emulator during each build. When one or more tablets are available for testing, we do not want to start an emulator. The plugin can not be configured to start an emulator only if there are no devices attached. The Android Emulator Plugin runs as pre and post build steps. The emulator is started before the build, and the cleanup is performed after the build. This makes it hard to configure Jenkins to start the emulator only if there are no physical devices available. Therefore we decide to modify the Android Emulator Plugin to perform a check before starting an emulator. We modify the plugin such that it provides an option to check if there are physical devices available, and only start an emulator if there are none. We have submitted a pull request with the changes\footnote{\url{https://github.com/jenkinsci/android-emulator-plugin/pull/50}}. 
The maintainer of the plugin can choose to merge the request into the main branch of the plugin. This would be an advantage for us, as we the do not have to maintain our fork of the plugin. \listingref{lst:deviceCheck} contains the main addition to the plugin; the method which checks for connected devices.

\begin{javacode}[caption=The devicesConnected method which checks for connected devices.,label=lst:deviceCheck]
private boolean devicesConnected(AndroidEmulatorContext emu, PrintStream logger, int adbPort, AbstractBuild<?,?> build) 
throws IOException, InterruptedException {
    final ByteArrayOutputStream deviceList = new ByteArrayOutputStream();
    //Setup a build environment to run the "adb devices" command in.
    final EnvVars buildEnv = build.getEnvironment(TaskListener.NULL);
    buildEnv.put("ANDROID_ADB_SERVER_PORT", Integer.toString(adbPort));
    if (emu.sdk().hasKnownHome()) {
        buildEnv.put("ANDROID_SDK_HOME", emu.sdk().getSdkHome());
    }
    if (emu.launcher().isUnix()) {
        buildEnv.put("LD_LIBRARY_PATH", String.format("%s/tools/lib", emu.sdk().getSdkRoot()));
    }
    //Run the command ADB -d devices
    Utils.runAndroidTool(emu.launcher(), buildEnv, deviceList, logger, emu.sdk(), Tool.ADB, "-d devices", null);
    String deviceOutput = deviceList.toString();
    ArrayList<String> deviceNames = getDeviceNames(deviceOutput, logger);
    if (deviceNames == null || deviceNames.isEmpty()) {
        return false;
    }
    else {
        return true;
    }
}
\end{javacode}
With this change, Jenkins will only start an emulator instance if there are no devices attached. This shortens the build time significantly. 
\section{Adapting Job Flow on Jenkins}

\begin{itemize}
  \item New jobflow:
  \begin{itemize}
    \item disconnect
    \item connect
    \item uninstall
    \item run build
    \item uninstall
    \item disconnect
  \end{itemize}
\end{itemize}